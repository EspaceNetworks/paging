#!/usr/bin/php -q
<?php
//include freepbx configuration 
$restrict_mods = true;
if (!@include_once(getenv('FREEPBX_CONF') ? getenv('FREEPBX_CONF') : '/etc/freepbx.conf')) {
    include_once('/etc/asterisk/freepbx.conf');
}
list($agi, $vars) = __agi();

$get = array(
		'ALERTINFO',
		'AMPUSER',
		'CALLINFO',
		'DOPTIONS',
		'DTIME',
		'PAGEMODE',
		'PAGE_CONF',
		'PAGE_CONF_OPTS',
		'PAGE_MEMBERS',
		'SIPURI',
		'STREAM',
		'VXML_URL'
);

foreach ($get as $g) {
	$vars[$g] = agi_get_var($g);
}

$vars['STREAM'] = $vars['STREAM'] ? $vars['STREAM'] : 'beep';

// TODO: this deals with the mainstream ones. We could check in the dialplan if 
//there are any others outside of these and only in that case evoke the
//new custom macro that gets generated to otherwise deal with these???

//set channel variables
$base_vars['__FORWARD_CONTEXT'] = 'block-cf';
$base_vars['AMPUSER'] = __pad_string($vars['AMPUSER']);
$chan_vars = array(
			'ALERTINFO',
			'CALLINFO',
			'DOPTIONS',
			'DTIME',
			'SIPURI',
			'SIPURI',
			'VXML_URL'
);

foreach ($chan_vars as $var) {
	if ($vars[$var] != '') {
		$base_vars[$var]  = __pad_string($vars[$var]);
	}
}


//dbug('vars', $vars);

/* TODO: run through the list here first and check for:
 *       future - check if each specific extension needs modifications to auto-answer channel variables
 *                so the conditional assignments can be skipped
 */

$page_members = explode('-', $vars['PAGE_MEMBERS']);

foreach ($page_members as $pm) {
	$pagemode = 'PAGE';
	$pass_vars = $base_vars;
	// don't page ourselves ever
	if ($pm == $vars['AMPUSER']) {
		continue;
	}
	// if not force mode, don't page busy extension (NOT_INUSE or ONHOLD are ok to page)
	if ($vars['PAGEMODE'] == 'PAGE') {
		$ext_state = agi_get_var("EXTENSION_STATE($pm)");
		if ($ext_state != 'NOT_INUSE' && $ext_state != 'ONHOLD') { //TODO: change to in_array or a function
			continue;
		}
	} elseif ($vars['PAGEMODE'] == 'SPAGE') {
		$ext_state = agi_get_var("EXTENSION_STATE($pm)");
		// if not idle but in a state we can try spying, then try
		if ($ext_state != 'NOT_INUSE' && $ext_state != 'ONHOLD') { //TODO: change to in_array or a function
			$device = $agi->database_get("DEVICE", $pm . '/dial');
			$device = $device['data'];
			$type = explode('/', $device, 2);
			if (strtolower($type[0]) != 'sip') {
				continue;
			}
			switch ($ext_state) {
				case "INUSE":
				case "BUSY":
				case "RINGINUSE":
				case "HOLDINUSE":
					// Try SPY
					$pagemode = 'SPAGE';
					$pass_vars['SP_DEVICE'] = __pad_string($device);
				break;
				default:
					// State is not amicable to spy or normal (such as RINGING) so skip it
					continue;
				break;
			}
		}
	}

	$astman->Originate(array(
			'Channel'     => 'Local/' . $pagemode . $pm . '@app-paging',
			'CallerID'    => $vars['calleridname'] . ' <' . $vars['callerid'] . '>',
			'Async'       => 'true',
			'Variable'    => $pass_vars,
			'Application' => ($amp_conf['ASTCONFAPP'] == 'app_confbridge' ? 'ConfBridge' : 'MeetMe'),
			'Data'        => $vars['PAGE_CONF'] . ',' . $vars['PAGE_CONF_OPTS'] . ',,'
	));
}

$beep = array(
		'Channel'		=> 'Local/s@app-page-stream',
		'CallerID'		=> 'Playback Stream',
		'Async'			=> 'true',
		'Variable'		=> array(
								'PAGE_CONF' => __pad_string($vars['PAGE_CONF']),
								'PAGE_CONF_OPTS' => 'xq'
							),
		'Application'	=> 'Playback',
		'Data'			=> $vars['STREAM']
);
//dbug($beep);
$astman->Originate($beep);

function __agi(){
	require_once('phpagi.php');
	$agi=new AGI();
	foreach($agi->request as $key => $value){//strip agi_ prefix from keys
		if(substr($key,0,4)=='agi_'){
			$opts[substr($key,4)]=$value;
		}
	}

	foreach($opts as $key => $value){//get passed in vars
		if(substr($key,0,4)=='arg_'){
			$expld=explode('=',$value);
			$opts[$expld[0]]=$expld[1];
			unset($opts[$key]);
		}
	}
	
	array_shift($_SERVER['argv']);
	foreach($_SERVER['argv'] as $arg){
		$arg=explode('=',$arg);
		//remove leading '--'
		if(substr($arg['0'],0,2) == '--'){$arg['0']=substr($arg['0'],2);}
		$opts[$arg['0']]=isset($arg['1'])?$arg['1']:null;
	}

	return array($agi, $opts);
}

function agi_get_var($value) {
	global $agi;
	$r = $agi->get_variable($value);
	
	if ($r['result'] == 1) {
		$result = $r['data'];
		return $result;
	}
	return '';
}

function __pad_string($string) {
	return str_replace(array('\\',',','='),array('\\\\','\\,','\\='),$string);
}

?>
